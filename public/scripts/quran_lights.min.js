const SuraNamesAr = [
  "الفاتحة",
  "البقرة",
  "آل عمران",
  "النساء",
  "المائدة",
  "الأنعام",
  "الأعراف",
  "الأنفال",
  "التوبة",
  "يونس",
  "هود",
  "يوسف",
  "الرعد",
  "إبراهيم",
  "الحجر",
  "النحل",
  "الإسراء",
  "الكهف",
  "مريم",
  "طـه",
  "الأنبياء",
  "الحج",
  "المؤمنون",
  "النور",
  "الفرقان",
  "الشعراء",
  "النمل",
  "القصص",
  "العنكبوت",
  "الروم",
  "لقمان",
  "السجدة",
  "الأحزاب",
  "سبأ",
  "فاطر",
  "يس",
  "الصافات",
  "ص",
  "الزمر",
  "غافر",
  "فصلت",
  "الشورى",
  "الزخرف",
  "الدخان",
  "الجاثية",
  "الأحقاف",
  "محمد",
  "الفتح",
  "الحجرات",
  "ق",
  "الذاريات",
  "الطور",
  "النجم",
  "القمر",
  "الرحمن",
  "الواقعة",
  "الحديد",
  "المجادلة",
  "الحشر",
  "الممتحنة",
  "الصف",
  "الجمعة",
  "المنافقون",
  "التغابن",
  "الطلاق",
  "التحريم",
  "الملك",
  "القلم",
  "الحاقة",
  "المعارج",
  "نوح",
  "الجن",
  "المزمل",
  "المدثر",
  "القيامة",
  "الإنسان",
  "المرسلات",
  "النبأ",
  "النازعات",
  "عبس",
  "التكوير",
  "الإنفطار",
  "المطففين",
  "الإنشقاق",
  "البروج",
  "الطارق",
  "الأعلى",
  "الغاشية",
  "الفجر",
  "البلد",
  "الشمس",
  "الليل",
  "الضحى",
  "الشرح",
  "التين",
  "العلق",
  "القدر",
  "البيِّنة",
  "الزلزلة",
  "العاديات",
  "القارعة",
  "التكاثر",
  "العصر",
  "الهمزة",
  "الفيل",
  "قريش",
  "الماعون",
  "الكوثر",
  "الكافرون",
  "النصر",
  "المسد",
  "الإخلاص",
  "الفلق",
  "الناس"
];
const SuraNamesEn = [
  "Al-Fatiha",
  "Al-Baqara",
  "Al Imran",
  "An-Nisa",
  "Al-Ma'ida",
  "Al-An'am",
  "Al-A'raf",
  "Al-Anfal",
  "At-Tawba",
  "Yunus",
  "Hud",
  "Yusuf",
  "Ar-Ra'd",
  "Ibrahim",
  "Al-Hijr",
  "An-Nahl",
  "Al-Isra",
  "Al-Kahf",
  "Maryam",
  "Ta-Ha",
  "Al-Anbiya",
  "Al-Hajj",
  "Al-Mu'minoon",
  "An-Nur",
  "Al-Furqan",
  "Ash-Shu'ara",
  "An-Naml",
  "Al-Qasas",
  "Al-Ankabut",
  "Ar-Rum",
  "Luqman",
  "As-Sajda",
  "Al-Ahzab",
  "Saba",
  "Fatir",
  "Ya Sin",
  "As-Saaffat",
  "Sad",
  "Az-Zumar",
  "Ghafir",
  "Fussilat",
  "Ash-Shura",
  "Az-Zukhruf",
  "Ad-Dukhan",
  "Al-Jathiya",
  "Al-Ahqaf",
  "Muhammad",
  "Al-Fath",
  "Al-Hujurat",
  "Qaf",
  "Adh-Dhariyat",
  "At-Tur",
  "An-Najm",
  "Al-Qamar",
  "Ar-Rahman",
  "Al-Waqi'a",
  "Al-Hadid",
  "Al-Mujadila",
  "Al-Hashr",
  "Al-Mumtahina",
  "As-Saff",
  "Al-Jumua",
  "Al-Munafiqun",
  "At-Taghabun",
  "At-Talaq",
  "At-Tahrim",
  "Al-Mulk",
  "Al-Qalam",
  "Al-Haaqqa",
  "Al-Maarij",
  "Nuh",
  "Al-Jinn",
  "Al-Muzzammil",
  "Al-Muddathir",
  "Al-Qiyama",
  "Al-Insan",
  "Al-Mursalat",
  "An-Naba",
  "An-Naziat",
  "Abasa",
  "At-Takwir",
  "Al-Infitar",
  "Al-Mutaffifin",
  "Al-Inshiqaq",
  "Al-Burooj",
  "At-Tariq",
  "Al-Ala",
  "Al-Ghashiya",
  "Al-Fajr",
  "Al-Balad",
  "Ash-Shams",
  "Al-Lail",
  "Ad-Dhuha",
  "Al-Inshirah",
  "At-Tin",
  "Al-Alaq",
  "Al-Qadr",
  "Al-Bayyina",
  "Az-Zalzala",
  "Al-Adiyat",
  "Al-Qaria",
  "At-Takathur",
  "Al-Asr",
  "Al-Humaza",
  "Al-Fil",
  "Quraysh",
  "Al-Ma'un",
  "Al-Kawthar",
  "Al-Kafirun",
  "An-Nasr",
  "Al-Masadd",
  "Al-Ikhlas",
  "Al-Falaq",
  "Al-Nas"
];
//TODO change to SuraVerseCount in all js files
const suraVerseCount = [
  7,
  286,
  200,
  176,
  120,
  165,
  206,
  75,
  129,
  109,
  123,
  111,
  43,
  52,
  99,
  128,
  111,
  110,
  98,
  135,
  112,
  78,
  118,
  64,
  77,
  227,
  93,
  88,
  69,
  60,
  34,
  30,
  73,
  54,
  45,
  83,
  182,
  88,
  75,
  85,
  54,
  53,
  89,
  59,
  37,
  35,
  38,
  29,
  18,
  45,
  60,
  49,
  62,
  55,
  78,
  96,
  29,
  22,
  24,
  13,
  14,
  11,
  11,
  18,
  12,
  12,
  30,
  52,
  52,
  44,
  28,
  28,
  20,
  56,
  40,
  31,
  50,
  40,
  46,
  42,
  29,
  19,
  36,
  25,
  22,
  17,
  19,
  26,
  30,
  20,
  15,
  21,
  11,
  8,
  8,
  19,
  5,
  8,
  8,
  11,
  11,
  8,
  3,
  9,
  5,
  4,
  7,
  3,
  6,
  3,
  5,
  4,
  5,
  6
];
const suraRevalationOrder = [
  5,
  87,
  89,
  92,
  112,
  55,
  39,
  88,
  113,
  51,
  52,
  53,
  96,
  72,
  54,
  70,
  50,
  69,
  44,
  45,
  73,
  103,
  74,
  102,
  42,
  47,
  48,
  49,
  85,
  84,
  57,
  75,
  90,
  58,
  43,
  41,
  56,
  38,
  59,
  60,
  61,
  62,
  63,
  64,
  65,
  66,
  95,
  111,
  106,
  34,
  67,
  76,
  23,
  37,
  97,
  46,
  94,
  105,
  101,
  91,
  109,
  110,
  104,
  108,
  99,
  107,
  77,
  2,
  78,
  79,
  71,
  40,
  3,
  4,
  31,
  98,
  33,
  80,
  81,
  24,
  7,
  82,
  86,
  83,
  27,
  36,
  8,
  68,
  10,
  35,
  26,
  9,
  11,
  12,
  28,
  1,
  25,
  100,
  93,
  14,
  30,
  16,
  13,
  32,
  19,
  29,
  17,
  15,
  18,
  114,
  6,
  22,
  20,
  21
];
const suraWordCountOrder = [
  29,
  6144,
  3503,
  3712,
  2837,
  3055,
  3344,
  1243,
  2506,
  1841,
  1947,
  1795,
  854,
  831,
  658,
  1845,
  1559,
  1583,
  972,
  1354,
  1174,
  1279,
  1051,
  1317,
  896,
  1322,
  1165,
  1441,
  982,
  818,
  550,
  374,
  1303,
  884,
  780,
  733,
  865,
  735,
  1177,
  1228,
  796,
  860,
  837,
  346,
  488,
  646,
  542,
  560,
  353,
  373,
  360,
  312,
  359,
  342,
  352,
  379,
  575,
  475,
  447,
  352,
  226,
  177,
  180,
  242,
  279,
  254,
  337,
  301,
  261,
  217,
  227,
  286,
  200,
  256,
  164,
  243,
  181,
  174,
  179,
  133,
  104,
  81,
  169,
  108,
  109,
  61,
  72,
  92,
  139,
  82,
  54,
  71,
  40,
  27,
  34,
  72,
  30,
  94,
  36,
  40,
  36,
  28,
  14,
  33,
  23,
  17,
  25,
  10,
  27,
  19,
  29,
  15,
  23,
  20
];
const suraCharCount = [
  139,
  25613,
  14605,
  15937,
  11892,
  12418,
  14071,
  5299,
  10873,
  7425,
  7633,
  7125,
  3450,
  3461,
  2797,
  7642,
  6480,
  6425,
  3835,
  5288,
  4925,
  5196,
  4354,
  5596,
  3786,
  5517,
  4679,
  5791,
  4200,
  3388,
  2121,
  1523,
  5618,
  3510,
  3159,
  2988,
  3790,
  2991,
  4741,
  4984,
  3282,
  3431,
  3508,
  1439,
  2014,
  2602,
  2360,
  2456,
  1493,
  1473,
  1510,
  1293,
  1405,
  1438,
  1585,
  1692,
  2475,
  1991,
  1913,
  1519,
  936,
  749,
  780,
  1066,
  1170,
  1067,
  1316,
  1258,
  1107,
  947,
  947,
  1089,
  840,
  1015,
  664,
  1065,
  815,
  766,
  762,
  538,
  425,
  326,
  740,
  436,
  459,
  249,
  293,
  378,
  573,
  335,
  249,
  312,
  164,
  102,
  156,
  281,
  112,
  394,
  156,
  164,
  158,
  122,
  70,
  133,
  96,
  73,
  112,
  42,
  95,
  79,
  81,
  47,
  71,
  80
];

function get_sura_index_from_sura_name(sura_name) {
  return SuraNamesEn.indexOf(sura_name) + 1;
}
//total score of all suras
const fullKhatmaCharCount = 322604;

const MEMORIZATION_STATE_NOT_MEMORIZED = "0";
const MEMORIZATION_STATE_WAS_MEMORIZED = "1";
const MEMORIZATION_STATE_MEMORIZED = "2";
const MEMORIZATION_STATE_BEING_MEMORIZED = "3";

const DAILY_SCORE_MODE = 0;
const MONTHLY_SCORE_MODE = 1;
const YEARLY_SCORE_MODE  = 2;
const DARK_DAYS_MODE = 3;
const LIGHT_DAYS_MODE = 4;

const SORT_ORDER_NORMAL = "normal";
const SORT_ORDER_REVELATION = "revelation_order";
const SORT_ORDER_LIGHT = "light";
const SORT_ORDER_CHAR_COUNT = "chars_count";
const SORT_ORDER_VERSE_COUNT = "verse_count";
const SORT_ORDER_WORD_COUNT = "word_count";
const SORT_ORDER_REFRESH_COUNT = "refresh_count";
const SCORE_CURRENCY = "$";

// Initialize Firebase
const config = {
    apiKey: "AIzaSyAn1GqNGEI3cB8pa5jBgaKxVdnf7xckw2c",
    authDomain: "quran-lights.firebaseapp.com",
    databaseURL: "https://quran-lights.firebaseio.com",
    projectId: "quran-lights",
    storageBucket: "quran-lights.appspot.com",
    messagingSenderId: "35819574492"
  };

  const SIGN_IN_ONLY_ELEMENTS = [
    "sort_order",
    "selected_total",
    "score",
    "light_days",
    "light-ratio-chart-container",
    "onquer-ratio-chart-container",
    "daily-score-chart",
    "monthly-score-chart",
    "yearly-score-chart",
    "dark_days_chart",
    "light_days_chart",
    "treemap-chart",
    "radar-chart",
    "khatma-progress-chart",
    "memorization-chart",
    "download",
    "import",
    "sort_order_container",
    "light_days_container",
    "daily-score-container",
    "today_score",
    "today_review_score",
    "today_read_score",
    "review_score_guage",
    "daily-read-guage"
  ];

  const SIGN_OUT_ONLY_ELEMENTS = [
    "email",
    "password",
    "quickstart-sign-up",
    "sign-in-with-google",
    "quickstart-password-reset" 
  ];

  SINGLE_CLICK_EVENT_DAMPING_DELAY = 300; 
  MAX_ELAPSED_DAYS_FOR_MEMORIZED_SURAS=  10; 
  DAILY_REVIEW_SCORE_THRESHOLD = fullKhatmaCharCount / 3;
  NUMBER_OF_DECIMAL_DIGITS = 1;

  const formatter = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
  });

  const AUTO_REFRESH_PERIOD = 30 * 60 * 1000;function sortNumber(a, b) {
  return a - b;
}

function sortByX(array) {
  return array.sort(function (a, b) {
    var x = a[0];
    var y = b[0];
    return x < y ? -1 : x > y ? 1 : 0;
  });
}

function showToast(message) {
  var x = document.getElementById("snackbar");
  x.textContent = message;
  x.className = "show";
}

function hideToast() {
  var x = document.getElementById("snackbar");
  x.className = x.className.replace("show", "");
}

function readableFormat(number) {
  number = Number(number);
  if (number >= 1000_000_000) {
    return (number / 1000_000_000).toFixed(NUMBER_OF_DECIMAL_DIGITS) + "B";
  } else if (number >= 1000_000) {
    return (number / 1000_000).toFixed(NUMBER_OF_DECIMAL_DIGITS) + "M";
  } else if (number >= 1000) {
    return (number / 1000).toFixed(NUMBER_OF_DECIMAL_DIGITS) + "K";
  } else {
    return number;
  }
}

function todayStartTimeStamp() {
  var now = new Date();
  var startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  var timestamp = startOfDay / 1000;
  return timestamp;
}

function componentToHex(c) {
  var hex = c.toString(16);
  return hex.length == 1 ? "0" + hex : hex;
}

function rgbToHex(r, g, b) {
  return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}

function sortByKey(array, key) {
  return array.sort(function (a, b) {
    var x = a[key];
    var y = b[key];
    return x < y ? -1 : x > y ? 1 : 0;
  });
}

function get_local_storage_object(key) {
  var object = is_json_string(localStorage.getItem(myUserId + "_" + key));
  if (object[0]) {
    return object[1];
  }

  return null;
}

function set_local_storage_object(key, value) {
  var saved = JSON.stringify(value);
  localStorage.setItem(myUserId + "_" + key, saved);

  return saved;
}

/**
 * 
 * @param {*} json_string string to be checked and parsed
 * @returns [success_boolean, result_object]
 */
function is_json_string(json_string) {
  var result;
  try {
    result = JSON.parse(json_string, null, 2);
  } catch (e) {
    console.log(e);
    return [false, {}];
  }
  return [true, result];
}

function get_humanized_period(days_count) {
  days_count = Number(days_count);
  if (days_count >= 365) {
    return (days_count / 365).toFixed(NUMBER_OF_DECIMAL_DIGITS) + "Y";
  } else if (days_count >= 30) {
    return (days_count / 30).toFixed(NUMBER_OF_DECIMAL_DIGITS) + "M";
  } else if (days_count >= 14) {
    return (days_count / 7).toFixed(NUMBER_OF_DECIMAL_DIGITS) + "W";
  } else {
    return days_count + "D";
  }
}

/**
 * This function attepts to retrieve a local storage value, 
 * if not found it creates it with the provided initial value.
 */
function get_initial_local_object(object_name, initial_value) {
  var stored_value = get_local_storage_object(object_name);
  if (stored_value) {
    return stored_value;
  }

  set_local_storage_object(object_name, initial_value);
  return initial_value;
}

//https://stackoverflow.com/a/2117523/1356559
function generate_uuid() {
  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  );
}

/**
   * returns timestamp in microseconds with server skew offset
   */
function get_time_stamp() {
  var millis = window.performance.timing.navigationStart + window.performance.now();
  var transactionTimeStamp = (millis + serverOffset) * 1000;
  return transactionTimeStamp;
}

function sort_transactions_by_timestamp(array) {
  return array.sort(function (a, b) {
    var x = (Number)(a.time);
    var y = (Number)(b.time);
    return x < y ? -1 : x > y ? 1 : 0;
  });
}

function clear_reviews() {
  var reviewsNode = document.getElementById("reviews");
  while (reviewsNode.firstChild) {
    reviewsNode.removeChild(reviewsNode.firstChild);
  }
}

function format(number) {
  return formatter.format(number);
}/*
* Author: Amr Lotfy 2020
*/

//var refreshPeriodDays = get_initial_local_object("refreshPeriodDays", MAX_ELAPSED_DAYS_FOR_MEMORIZED_SURAS);

function get_refresh_period_days() {
    return get_initial_local_object("refreshPeriodDays", MAX_ELAPSED_DAYS_FOR_MEMORIZED_SURAS);
};

function set_refresh_period_days(value) {
    if (!value) return;
    //refreshPeriodDays = value;
    set_local_storage_object("refreshPeriodDays", value);
}

/**
 * Used to record the most recent transaction timestamp so in the next fetch we get more recent transactions only.
 */
var lastTransactionTimeStamp = "0";

var update_stamp = 0;
var serverOffset = 0;
var lightRatio = 0;
var conquerRatio = 0;

var surasColorTable = [];
var selected_suras = [];

var sort_order;

var state = {};
var myUserId;
var user;

var surasHistory = {};//TODO replace {} with new Map()
var sortedTimestampSuraArray = [];

var colorHash = {};
var elapsed_days = [];

var review_today = 0;
var read_daily_target = 100_000;
var review_daily_target = 100_000; 

var scores = {};
var memorization_state = {};/**
 * Used to avoid reacting to update_stamp triggers caused by self
 */
var ownTimeStamps = [];

function onTimeStampUpdated() {
  timeStampTriggerTimerRef = null;
  console.log("Fetching history...");
  initCells();
}

function skew() {
  var offsetRef = firebase.database().ref(".info/serverTimeOffset");
  offsetRef.on("value", function (snap) {
    serverOffset = snap.val();
  });
}

function bounce(suraIndex) {
  $(".sura-" + suraIndex).addClass("animated bounceIn");
}

/**
 * upload queue, gets filled on refreshes and cell memorization state updates, then a dispatcher should process it async.
 * TODO read on user login
 */
function get_upload_queue() {
  return get_initial_local_object("upload_queue", []);
}

function set_upload_queue(queue) {
  set_local_storage_object("upload_queue", queue);
}

var reference_to_scheduled_upload_function;

// Start uploading after 10 seconds of last enqueue
const UPLOAD_DISPATCH_DAMPING_DELAY = 10_000;
function enqueue_for_upload(transaction_record) {
  console.log("enqueue_for_upload: \n" + transaction_record);
  var queue = get_upload_queue();
  queue.unshift(transaction_record);
  set_upload_queue(queue);
  clearTimeout(reference_to_scheduled_upload_function);
  reference_to_scheduled_upload_function = setTimeout(dispatch_uploads, UPLOAD_DISPATCH_DAMPING_DELAY);
}

function enqueue_batch_for_upload(records) {
  console.log("enqueue_for_upload: \n" + records);
  var queue = get_upload_queue();
  queue = records.concat(queue);
  set_upload_queue(queue);
  dispatch_uploads();
}

function dispatch_uploads() {
  //upload all enqueued transactions
  console.log("Upload Queue: ", get_upload_queue());
  if (get_upload_queue().length == 0) {
    return;
  }

  //TODO start handling upload transactions records here
  var updates = {};
  get_upload_queue().forEach((transacton_record) => {
    var transactionTimeStamp = get_time_stamp();
    firebase.database().ref(`users/${firebase.auth().currentUser.uid}/Master/reviews/` + transactionTimeStamp).set({});
    updates[`users/${firebase.auth().currentUser.uid}/Master/reviews/` + transactionTimeStamp] = transacton_record;
    lastTransactionTimeStamp = transactionTimeStamp;
    ownTimeStamps.push(lastTransactionTimeStamp);
  });

  firebase.database().ref().update(updates, function (error) {
    if (error) {
      alert("Data could not be saved, check your connection. " + error);
      console.log("upload ERROR: " + updates);
      //TODDO reschedule upload attempt!!
      clearTimeout(reference_to_scheduled_upload_function);
      reference_to_scheduled_upload_function = setTimeout(dispatch_uploads, UPLOAD_DISPATCH_DAMPING_DELAY * 3);
    } else {
      console.log("upload success: " + updates);
      //trigger update on other devices
      firebase
        .database()
        .ref(
          "users/" + firebase.auth().currentUser.uid + "/Master/update_stamp"
        )
        .set(lastTransactionTimeStamp);
      remove_from_queue(updates);
    }
  });

}

function get_firebase_reviews_node() {
  return firebase.database().ref(`users/${firebase.auth().currentUser.uid}/Master/reviews`);
}

function get_firebase_update_stamp_node() {
  return firebase.database().ref("users/" + firebase.auth().currentUser.uid + "/Master/update_stamp");
}

function get_firebase_settings_node() {
  return firebase.database().ref("users/" + firebase.auth().currentUser.uid + "/Master/settings");
}

function remove_from_queue(transactions_records_to_be_removed) {
  var upload_queue = get_upload_queue();

  for (var key in transactions_records_to_be_removed) {
    upload_queue = upload_queue.filter(function (upload_queue_entry) {
      return upload_queue_entry.uuid !== transactions_records_to_be_removed[key].uuid;
    });
  }

  set_upload_queue(upload_queue);
}

const TRANSACTIONS_HISTORY_KEY = "transactions_history";
function get_transactions_history() {
  return get_initial_local_object(TRANSACTIONS_HISTORY_KEY, []);
}

function add_to_transactions_history(transactions_records) {
  var transactions_history = get_transactions_history();

  transactions_records = transactions_records.filter(function(transaction) {
    for(var old_transaction in transactions_history) {
      if (old_transaction.uuid == transaction.uuid) {
        return false;
      }
    }
    return true;
  });

  var merged_history = transactions_history.concat(transactions_records);
  //merged_history.sort(sort_transactions_by_timestamp);
  set_local_storage_object(TRANSACTIONS_HISTORY_KEY, merged_history);
}

function fetch_full_history_once() {
  var already_fetched_history = get_initial_local_object("already_fetched_history", false);
  if (already_fetched_history) {
    return;
  }

  myUserId = firebase.auth().currentUser.uid;
  firebase
      .database()
      .ref("users/" + myUserId + "/Master/reviews")
      .once("value", function (snapshot) {
    if (snapshot != null) {
      var transactions_records = [];
      snapshot.forEach(function (childSnapshot) {
        var transaction_record = childSnapshot.val();
        transactions_records.push(transaction_record);

      });
      add_to_transactions_history(transactions_records);
      set_local_storage_object("already_fetched_history", true);
      console.log("fetch_full_history: " + transactions_records);
    }
  });
}//TODO fix for new FDB structure
//TODO put in upload queue and schedule a dispatcher function
function refreshSura(suraIndex, refreshTimeStamp) {
  //TODO update model
  //TODO check for empty history array

  //update FDB
  var transaction_record = {
    op: "refresh",
    sura: suraIndex,
    time: refreshTimeStamp
  };

  var transactions_records = [];
  transactions_records.push(transaction_record);
  add_to_transactions_history(transactions_records);

  enqueue_for_upload(transaction_record);
  surasHistory[suraIndex].history.push(transaction_record.time);
  sortedTimestampSuraArray = [];
  refreshCountSortedSuraArray = [];
  playSuraRefreshSound();
  add_sura_cells();
  animate_score_elements();
}

//TODO animate ony after score change
function animate_score_elements(){
  $(".score").addClass("animated bounceIn");
}

function refreshByName(suraName) {
  refreshSura(SuraNamesEn.indexOf(suraName) + 1, Math.floor(Date.now() / 1000))
}

var buildingSurasFlag = false;

firebase.initializeApp(config);

var timeStampTriggerTimerRef = null;
var periodicRefreshTimerRef = null;
var isFirstLoad = 1;

window.onload = function () {
  Sentry.init({ dsn: 'https://55c264ec9a484103890f2ca7ad8a4543@sentry.io/238887' });
  init_collapsibles();
  initApp();
};

function set_light_days() {
  var light_days_selection_element = document.getElementById("light_days");
  var light_days_count = Number(light_days_selection_element.value);
  set_refresh_period_days(light_days_count);
  add_sura_cells();
}

function setup_light_days_options() {
  var light_days_selection_element = document.getElementById("light_days");
  light_days_selection_element.innerHTML = "";
  for (var i = 1; i < 31; i++) {
    var option = document.createElement("option");
    option.value = i;
    option.text = i;
    light_days_selection_element.appendChild(option);
  }

  light_days_selection_element.value = get_refresh_period_days();
}

function show_sign_in_only_elements() {
  for (var i = 0; i < SIGN_IN_ONLY_ELEMENTS.length; i++) {
    var element = document.getElementById(SIGN_IN_ONLY_ELEMENTS[i]);
    if(element) element.style.display = "block";
  }

  for (var i = 0; i < SIGN_OUT_ONLY_ELEMENTS.length; i++) {
    var element = document.getElementById(SIGN_OUT_ONLY_ELEMENTS[i]);
    if(element) element.style.display = "none";
  }
}

function hide_sign_in_only_elements(){
  for (var i = 0; i < SIGN_IN_ONLY_ELEMENTS.length; i++) {
    var element = document.getElementById(SIGN_IN_ONLY_ELEMENTS[i]);
    if(element) element.style.display = "none";
  }

  for (var i = 0; i < SIGN_OUT_ONLY_ELEMENTS.length; i++) {
    var element = document.getElementById(SIGN_OUT_ONLY_ELEMENTS[i]);
    if(element) element.style.display = "block";
  }
}

function init_collapsibles() {
  var coll = document.getElementsByClassName("collapsible");
  var i;

  for (i = 0; i < coll.length; i++) {
    coll[i].addEventListener("click", function () {
      this.classList.toggle("active");
      var content = this.nextElementSibling;
      if (content.style.display === "block") {
        content.style.display = "none";
      } else {
        content.style.display = "block";
      }
    });
  }
}/**
 * initApp handles setting up UI event listeners and registering Firebase auth listeners:
 *  - firebase.auth().onAuthStateChanged: This listener is called when the user is signed in or
 *    out, and that is where we update the UI.
 */
function initApp() {
  // Listening for auth state changes.
  // [START authstatelistener]
  document
    .getElementById("password")
    .addEventListener("keyup", function (event) {
      event.preventDefault();
      if (event.keyCode == 13) {
        document.getElementById("quickstart-sign-in").click();
      }
    });
  firebase.auth().onAuthStateChanged(function (user) {
    document.getElementById("quickstart-sign-in").disabled = false;
    if (user) {
      skew();
      document.title = "Quran Lights [" + user.email + "]";
      show_sign_in_only_elements();
      //document.getElementById("sign-in-with-facebook").style.display = "none";
      //document.getElementById("sign-in-with-twitter").style.display = "none";
      var update_timestamp_ref = firebase.database()
        .ref("users/" + firebase.auth().currentUser.uid + "/Master/update_stamp");
      update_timestamp_ref.on("value", function (snapshot) {
        var updatedValue = snapshot.val();
        var indexOfTimeStamp = ownTimeStamps.indexOf(updatedValue);
        if (indexOfTimeStamp != -1) {
          //delete matching own timestamp
          ownTimeStamps.splice(indexOfTimeStamp, 1);
          console.log("dropping own update.");
          return;
        }
        //stabilize successive triggers
        if (timeStampTriggerTimerRef != null) {
          clearTimeout(timeStampTriggerTimerRef);
          console.log("Dropped repeated timestamp trigger.. ");
        }
        timeStampTriggerTimerRef = setTimeout(onTimeStampUpdated, isFirstLoad == 1 ? 0 : 5000);
        isFirstLoad = 0;
      });
    }
    else {
      clearInterval(periodicRefreshTimerRef);
      hide_sign_in_only_elements();
      //document.getElementById("sign-in-with-facebook").style.display = "block";
      //document.getElementById("sign-in-with-twitter").style.display = "block";
      // User is signed out.
      document.getElementById("quickstart-sign-in").textContent = "Sign in";
      //empty score
      document.getElementById("score").textContent = "--";
      //document.getElementById('quickstart-account-details').textContent = 'null';
    }
  });
  // [END authstatelistener]
  document
    .getElementById("quickstart-sign-in")
    .addEventListener("click", toggleSignIn, false);
  document
    .getElementById("quickstart-sign-up")
    .addEventListener("click", handleSignUp, false);
  document
    .getElementById("sign-in-with-google")
    .addEventListener("click", signInWithGoogle, false);
  //document.getElementById('sign-in-with-facebook').addEventListener('click', signInWithFacebook, false);
  //document.getElementById('sign-in-with-twitter').addEventListener('click', signInWithTwitter, false);
}//Do Refresh at midnight
var now = new Date();
var eta = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 0) - now;
setTimeout(function(){
  add_sura_cells();
}, eta);

function initCells() {
  user = firebase.auth().currentUser;
  if (user) {
    document.getElementById("quickstart-sign-in").textContent = "Sign out " + user.email;
    // User is signed in.
    var displayName = user.displayName;
    var email = user.email;
    var emailVerified = user.emailVerified;
    var photoURL = user.photoURL;
    var isAnonymous = user.isAnonymous;
    var uid = user.uid;
    var providerData = user.providerData;
    myUserId = firebase.auth().currentUser.uid;
    var database = firebase.database();

    var lastTimeStamp = get_local_storage_object("lastTransactionTimeStamp");

    if (lastTimeStamp) {
      lastTransactionTimeStamp = lastTimeStamp;
    } else {
      lastTransactionTimeStamp = 0;
      set_local_storage_object("lastTransactionTimeStamp", 0);
    }
    var history = get_local_storage_object("surasHistory");
    if (history) {
      surasHistory = history;
      console.log("LOcalStorage SurasHistory: \n", surasHistory);
    } else {
      lastTransactionTimeStamp = 0;
      set_local_storage_object("lastTransactionTimeStamp", 0);
      console.log("LocalStorage has no/invalid SurasHistory information: \n", surasHistory);
    }

    console.log("grapping transactions after ", lastTransactionTimeStamp);

    sort_order = get_local_storage_object("sort_order");
    if (sort_order) {
      set_sort_order_with_value(sort_order);
    } else {
      set_sort_order_with_value(SORT_ORDER_NORMAL);
    }

    selected_suras = get_local_storage_object("selected_suras")
    if (!selected_suras) { 
      selected_suras = []; 
    }

    var reviewsRef = firebase
      .database()
      .ref("users/" + myUserId + "/Master/reviews")
      .orderByKey()
      .startAt(lastTransactionTimeStamp.toString());
      
    showToast("Fetching history...");
    reviewsRef.once("value", function (snapshot) {
      hideToast();
      //surasHistory = {};
      var bounceList = [];
      if (snapshot != null) {
        snapshot.forEach(function (childSnapshot) {
          var transactionTimeStamp = childSnapshot.key;
          if (lastTransactionTimeStamp == transactionTimeStamp) {
            return;
          }
          if (Number(transactionTimeStamp) > Number(lastTransactionTimeStamp)) {
            lastTransactionTimeStamp = transactionTimeStamp;
            set_local_storage_object("lastTransactionTimeStamp", lastTransactionTimeStamp);
          }
          var transactionRecord = childSnapshot.val();
          var suraIndex = transactionRecord.sura;
          bounceList.push(suraIndex);
          if (surasHistory[suraIndex] == null) {
            surasHistory[suraIndex] = {};
            surasHistory[suraIndex].suraIndex = suraIndex;
            surasHistory[suraIndex].history = [];
          }
          switch (transactionRecord.op) {
            case "memorize":
              surasHistory[suraIndex].memorization = transactionRecord.state;
              break;
            case "refresh":
              if (surasHistory[suraIndex].history.indexOf(transactionRecord.time) == -1) {
                surasHistory[suraIndex].history.push(transactionRecord.time);
              }
              else {
                console.log("duplicate refresh eliminated ", transactionRecord);
              }
          }
        });
        for (var suraIndex in surasHistory.keys) {
          surasHistory[suraIndex].history.sort(sortNumber);
        }
        set_local_storage_object("surasHistory", surasHistory);
        set_local_storage_object("lastTransactionTimeStamp", lastTransactionTimeStamp);
      }

      document.getElementById("reviews").textContent = "";
      sortedTimestampSuraArray = [];
      refreshCountSortedSuraArray = [];
      add_sura_cells();
      bounceList.forEach(function (suraIndex) {
        bounce(suraIndex);
      });
      if(bounceList.length) {
        playSuraRefreshSound();
      }
    });
  }
}
//to detect if control modifier key is pressed
var alt_pressed = false;
var shift_pressed = false;
var ctrl_pressed = false;
var cmd_pressed = false;
function cacheIt(event) {
  alt_pressed = event.altKey;
  shift_pressed = event.shiftKey;
  ctrl_pressed = event.ctrlKey;
  cmd_pressed = event.metaKey;
  console.log(event);
  if (event.key == "l" && event.type == "keyup" && event.ctrlKey) {
    set_sort_order_with_value("light");
  }

  if (event.key == "n" && event.type == "keyup" && event.ctrlKey) {
    set_sort_order_with_value("normal");
  }

  if (event.key == "c" && event.type == "keyup" && event.ctrlKey) {
    set_sort_order_with_value("chars_count");
  }

  if (event.key == "v" && event.type == "keyup" && event.ctrlKey) {
    set_sort_order_with_value("verse_count");
  }

  if (event.key == "w" && event.type == "keyup" && event.ctrlKey) {
    set_sort_order_with_value("word_count");
  }

  if (event.key == "f" && event.type == "keyup" && event.ctrlKey) {
    set_sort_order_with_value("refresh_count");
  }

  if (event.key == "r" && event.type == "keyup" && event.ctrlKey) {
    set_sort_order_with_value("revelation_order");
  }

  if (event.key == "d" && event.type == "keyup" && event.ctrlKey) {
    deselectAll();
  }

}
document.onkeydown = cacheIt;
document.onkeyup = cacheIt;//TODO move to sync.js file
function set_memorization(suraIndex, state) {
  var transaction_record = {
    op: "memorize",
    sura: suraIndex,
    state: state,
    time: get_time_stamp()
  };
  var transactions_records = [];
  transactions_records.push(transaction_record);
  add_to_transactions_history(transactions_records);

  enqueue_for_upload(transaction_record);
  // memorization should be array?
  surasHistory[suraIndex].memorization = state;
  sortedTimestampSuraArray = [];
  refreshCountSortedSuraArray = [];
  if (state == MEMORIZATION_STATE_MEMORIZED) {
    playSuraRefreshSound();
    animate_sura_cell(suraIndex);
  }
  
  add_sura_cells();
}

function animate_sura_cell(index) {
  $("sura-" + index).addClass("animate bounceIn");
}

function toggle_memorization(suraIndex) {
  if (surasHistory[suraIndex].memorization == MEMORIZATION_STATE_MEMORIZED) {
    set_memorization(suraIndex, MEMORIZATION_STATE_NOT_MEMORIZED);
  } else {
    set_memorization(suraIndex, MEMORIZATION_STATE_MEMORIZED);
  }
}

//TODO optimize to avoid repeating this calculation.
function get_memorization_data() {
  var memorizationData = {};
  var memorized_percentage = 0;
  var was_memorized_percentage = 0;
  var being_memorized_percentage = 0;
  var not_memorized_percentage = 0;

  var memorized_amount = 0;
  var was_memorized_amount = 0;
  var being_memorized_amount = 0;
  var not_memorized_amount = 0;

  var memorized_drill_down_array = [];
  var was_mmorized_drill_down_array = [];
  var being_memorized_drill_down_array = [];
  var not_memorized_drill_down_array = [];

  for (var suraIndex = 0; suraIndex < 114; suraIndex++) {
    var entry = {
      name: SuraNamesEn[suraIndex],
      y: suraCharCount[suraIndex]
    };
    var suraScore = suraCharCount[suraIndex];
    switch (surasHistory[suraIndex + 1].memorization) {
      case "1":
        entry.drilldown = "WasMemorized";
        was_mmorized_drill_down_array.push(entry);
        was_memorized_amount += suraScore;
        break;

      case "2":
        entry.drilldown = "Memorized";
        memorized_drill_down_array.push(entry);
        memorized_amount += suraScore;
        break;

      case "3":
        entry.drilldown = "BeingMemorized";
        being_memorized_drill_down_array.push(entry);
        being_memorized_amount += suraScore;
        break;

      default:
        entry.drilldown = "NotMemorized";
        not_memorized_drill_down_array.push(entry);
        not_memorized_amount += suraScore;
    }
  }

  memorization_state = {
    "not_memorized" : not_memorized_amount,
    "being_memorized" : being_memorized_amount,
    "memorized" : memorized_amount,
    "was_memorized" : was_memorized_amount
  };

  being_memorized_percentage =
    (being_memorized_amount / fullKhatmaCharCount) * 100;
  memorized_percentage = (memorized_amount / fullKhatmaCharCount) * 100;
  was_memorized_percentage = (was_memorized_amount / fullKhatmaCharCount) * 100;
  not_memorized_percentage = (not_memorized_amount / fullKhatmaCharCount) * 100;

  memorizationData.data = [
    {
      name: "Memorized",
      y: memorized_percentage,
      drilldown: "Memorized",
      sliced: true
    },
    {
      name: "Being Memorized",
      y: being_memorized_percentage,
      drilldown: "BeingMemorized"
    },
    {
      name: "Was Memorized",
      y: was_memorized_percentage,
      drilldown: "WasMemorized"
    },
    {
      name: "Not Memorized",
      y: not_memorized_percentage,
      drilldown: "NotMemorized"
    }
  ];

  memorizationData.drilldown = [
    {
      name: "Memorized",
      id: "Memorized",
      data: memorized_drill_down_array
    },
    {
      name: "BeingMemorized",
      id: "BeingMemorized",
      data: being_memorized_drill_down_array
    },
    {
      name: "WasMemorized",
      id: "WasMemorized",
      data: was_mmorized_drill_down_array
    },
    {
      name: "NotMemorized",
      id: "NotMemorized",
      data: not_memorized_drill_down_array
    }
  ];

  return memorizationData;
}

function drawMemorizationPieChart() {
  // Build the chart

  var memorizationOptions = get_memorization_data();
  var data = memorizationOptions.data;

  Highcharts.chart("memorization-chart", {
    chart: {
      plotBackgroundColor: null,
      plotBorderWidth: null,
      plotShadow: false,
      type: "pie"
    },
    title: {
      text: "Memorization Progress"
    },
    tooltip: {
      pointFormat: "{series.name}: <b>{point.percentage:.1f}%</b>"
    },
    plotOptions: {
      pie: {
        allowPointSelect: true,
        cursor: "pointer",
        dataLabels: {
          enabled: true,
          format: "<b>{point.name}</b>: {point.percentage:.1f} %",
          style: {
            color:
              (Highcharts.theme && Highcharts.theme.contrastTextColor) ||
              "green"
          },
          connectorColor: "silver"
        }
      }
    },
    series: [
      {
        name: "Memorization Progress",
        data: data
      }
    ],

    drilldown: {
      series: memorizationOptions.drilldown
    }
  });
}function create_dark_days_map(start_date) {
  var dark_days = {};
  var today = new Date();
  var start_year = start_date.getFullYear();
  var start_month = start_date.getMonth() + 1;
  var start_day = start_date.getDate();
  var year_now = today.getFullYear();
  var month_now = today.getMonth() + 1;
  var day_now = today.getDate();

  for (var year_index = start_year; year_index <= year_now; year_index++) {
    for (var month_index = 1; month_index <= 12; month_index++) {
      if (year_index == start_year && month_index < start_month) {
        continue;
      }

      if (year_index == year_now && month_index > month_now) {
        continue;
      }

      var number_of_days_per_month = new Date(year_index, month_index, 0).getDate();
      var days_array = [];
      for (var day_index = 1; day_index <= number_of_days_per_month; day_index++) {
        if (year_index == start_year && month_index == start_month && day_index < start_day) {
          continue;
        }

        if (year_index == year_now && month_index == month_now && day_index > day_now) {
          continue;
        }

        days_array.push(day_index);

      }

      var light_days_key = year_index + "-" + month_index;
      
      dark_days[light_days_key] = days_array;
      ;
    }
  }

  return dark_days;
}

function dark_days_data() {

  var result = [];

  var sortedEntries = get_flat_timestamp_score_array();
  if (!sortedEntries || sortedEntries.length == 0) {
    return [];
  }
  var dark_days_map = create_dark_days_map(new Date(sortedEntries[0][0]));

  var prevMonth = new Date(sortedEntries[0][0]).getMonth() + 1;
  var prevYear = new Date(sortedEntries[0][0]).getFullYear();
  var year_month_key = prevYear + "-" + prevMonth;


  for (var index = 0; index < sortedEntries.length; index++) {
    var date = new Date(sortedEntries[index][0]);
    var currentDate = date.getDate();
    var currentMonth = date.getMonth() + 1;
    var currentYear = date.getFullYear();

    var year_month_key = currentYear + "-" + currentMonth;
    var element_to_be_deleted_index = dark_days_map[year_month_key].indexOf(currentDate);
    if (element_to_be_deleted_index > -1) {
      dark_days_map[year_month_key].splice(element_to_be_deleted_index, 1);
    }
  }

  for (var key in dark_days_map) {
    dark_days_map[key] = dark_days_map[key].length;
    result.push([new Date(key + "-" + "15").getTime(), dark_days_map[key]]);
  }

  return result;
}

function light_days_data() {

  var result = [];

  var sortedEntries = get_flat_timestamp_score_array();
  if (!sortedEntries || sortedEntries.length == 0) {
    return [];
  }
  var light_days_map = {};

  var prevMonth = new Date(sortedEntries[0][0]).getMonth() + 1;
  var prevYear = new Date(sortedEntries[0][0]).getFullYear();
  var year_month_key = prevYear + "-" + prevMonth;


  for (var index = 0; index < sortedEntries.length; index++) {
    var date = new Date(sortedEntries[index][0]);
    var currentDate = date.getDate();
    var currentMonth = date.getMonth() + 1;
    var currentYear = date.getFullYear();

    var year_month_key = currentYear + "-" + currentMonth;
    if (!light_days_map[year_month_key]) {
      light_days_map[year_month_key] = [];
    }
    var element_to_be_deleted_index = light_days_map[year_month_key].indexOf(currentDate);
    if (element_to_be_deleted_index == -1) {
      light_days_map[year_month_key].push(currentDate);
    }
  }

  for (var key in light_days_map) {
    light_days_map[key] = light_days_map[key].length;
    result.push([new Date(key + "-" + "15").getTime(), light_days_map[key]]);
  }

  return result;
}function set_sort_order() {
  set_sort_order_with_value(document.getElementById("sort_order").value);
}

function  set_sort_order_with_value(value)  {
  if (!value) { 
    value = "normal";
  }

  sort_order = value;
  set_local_storage_object("sort_order", sort_order);
  document.getElementById("sort_order").value = value;

  add_sura_cells();
}

var revalationSortedSuraArray = [];

function createRevalationSuraOrderArray() {
  if (revalationSortedSuraArray.length != 0) {
    return;
  }
  for (suraIndex = 1; suraIndex <= 114; suraIndex++) {
    var suraWithCharCountRecord = {
      suraID: suraIndex,
      revalOrder: suraRevalationOrder[suraIndex - 1]
    };
    revalationSortedSuraArray.push(suraWithCharCountRecord);
  }

  revalationSortedSuraArray = sortByKey(
    revalationSortedSuraArray,
    "revalOrder"
  );
}

var verseCountSortedSuraArray = [];

function createVerseCountSuraOrderArray() {
  if (verseCountSortedSuraArray.length != 0) {
    return;
  }
  for (suraIndex = 1; suraIndex <= 114; suraIndex++) {
    var suraWithCharCountRecord = {
      suraID: suraIndex,
      verseCount: suraCharCount[suraIndex - 1]
    };
    verseCountSortedSuraArray.push(suraWithCharCountRecord);
  }

  verseCountSortedSuraArray = sortByKey(
    verseCountSortedSuraArray,
    "verseCount"
  );
}

var characterCountSortedSuraArray = [];

function createCharCountSuraOrderArray() {
  if (characterCountSortedSuraArray.length != 0) {
    return;
  }
  for (suraIndex = 1; suraIndex <= 114; suraIndex++) {
    var suraWithCharCountRecord = {
      suraID: suraIndex,
      charCount: suraCharCount[suraIndex - 1]
    };
    characterCountSortedSuraArray.push(suraWithCharCountRecord);
  }

  characterCountSortedSuraArray = sortByKey(
    characterCountSortedSuraArray,
    "charCount"
  );
}

var wordCountSortedSuraArray = [];

function createWordCountSuraOrderArray() {
  if (wordCountSortedSuraArray.length != 0) {
    return;
  }
  for (suraIndex = 1; suraIndex <= 114; suraIndex++) {
    var suraWithWordCountRecord = {
      suraID: suraIndex,
      wordCount: suraCharCount[suraIndex - 1]
    };
    wordCountSortedSuraArray.push(suraWithWordCountRecord);
  }

  wordCountSortedSuraArray = sortByKey(wordCountSortedSuraArray, "wordCount");
}

function createSortedTimeStampSuraArray() {
  if (sortedTimestampSuraArray.length != 0) {
    return;
  }

  for (suraIndex = 1; suraIndex <= 114; suraIndex++) {
    var timeStampsArray =
      surasHistory[suraIndex].history != null
        ? surasHistory[suraIndex].history
        : [];
    var mostRecentTimestamp =
      timeStampsArray.length > 0
        ? timeStampsArray[timeStampsArray.length - 1]
        : 0;
    var suraWithLastTimeStampRecord = {
      suraID: suraIndex,
      timeStamp: mostRecentTimestamp
    };
    sortedTimestampSuraArray.push(suraWithLastTimeStampRecord);
  }

  sortedTimestampSuraArray = sortByKey(sortedTimestampSuraArray, "timeStamp");
}

var refreshCountSortedSuraArray = [];

function createSortedRefreshCountSuraArray() {
  if (refreshCountSortedSuraArray.length != 0) {
    return;
  }
  for (suraIndex = 1; suraIndex <= 114; suraIndex++) {
    var timeStampsArray =
      surasHistory[suraIndex] != null && surasHistory[suraIndex].history != null
        ? surasHistory[suraIndex].history
        : [];
    var mostRecentTimestamp = timeStampsArray.length;
    var suraWithRefreshCountRecord = {
      suraID: suraIndex,
      refreshCount: mostRecentTimestamp
    };
    refreshCountSortedSuraArray.push(suraWithRefreshCountRecord);
  }

  refreshCountSortedSuraArray = sortByKey(
    refreshCountSortedSuraArray,
    "refreshCount"
  );
}

function sortedSuraIndexConverter(index) {
  switch (sort_order) {
    //Normal sura order
    case SORT_ORDER_NORMAL:
      return index;

    //light order
    case SORT_ORDER_LIGHT:
      createSortedTimeStampSuraArray();
      return sortedTimestampSuraArray[index - 1].suraID;

    //character count order
    case SORT_ORDER_CHAR_COUNT:
      createCharCountSuraOrderArray();
      return characterCountSortedSuraArray[index - 1].suraID;

    //verse count order
    case SORT_ORDER_VERSE_COUNT:
      createVerseCountSuraOrderArray();
      return verseCountSortedSuraArray[index - 1].suraID;

    //word count sort
    case SORT_ORDER_WORD_COUNT:
      createWordCountSuraOrderArray();
      return wordCountSortedSuraArray[index - 1].suraID;

    //revalation order
    case SORT_ORDER_REVELATION:
      createRevalationSuraOrderArray();
      return revalationSortedSuraArray[index - 1].suraID;

    //refresh count
    case SORT_ORDER_REFRESH_COUNT:
      createSortedRefreshCountSuraArray();
      return refreshCountSortedSuraArray[index - 1].suraID;

    default:
      return index;
  }
}
async function drawTreeMapChart(DevId) {
  Highcharts.chart(DevId, {
    colorAxis: {
      minColor: "#000",
      maxColor: "#00FF00"
    },
    series: [
      {
        type: "treemap",
        layoutAlgorithm: "squarified",
        data: getTreeMapData(),
        events: {
          click: function (event) {
            click_handler(get_sura_index_from_sura_name(event.point.name));
            console.log("clicked cell: ", event.point.name);
          }
        }
      }
    ],
    title: {
      text: "Lights TreeMap"
    }
  });
}

function getTreeMapData() {
  var data = [];
  for (var suraIndex = 0; suraIndex < 114; suraIndex++) {
    var suraTile = {};
    suraTile.name = SuraNamesEn[suraIndex];
    suraTile.value = suraCharCount[suraIndex];
    suraTile.colorValue = surasColorTable[suraIndex];
    data.push(suraTile);
  }

  return data;
}async function updateGuageChart(chartID, title, ratio) {
    chartRatio = null;
    chartRatio = new Highcharts.chart(
      chartID,
      Highcharts.merge(gaugeOptions, {
        yAxis: {
          min: 0,
          max: 100,
          title: {
            text: title
          }
        },
  
        credits: {
          enabled: false
        },
  
        series: [
          {
            name: title,
            data: [ratio],
            dataLabels: {
              format:
                '<div style="text-align:center"><span style="font-size:25px;color:' +
                "black" +
                '">{y:.2f}</span><br/>' +
                '<span style="font-size:12px;color:silver">percent</span></div>'
            },
            tooltip: {
              valueSuffix: " percent"
            }
          }
        ]
      })
    );
  
    return chartRatio;
  }

  var gaugeOptions = {
    chart: {
      type: "solidgauge"
    },
  
    title: null,
  
    pane: {
      center: ["50%", "85%"],
      size: "140%",
      startAngle: -90,
      endAngle: 90,
      background: {
        backgroundColor: "#EEE",
        innerRadius: "60%",
        outerRadius: "100%",
        shape: "arc"
      }
    },
  
    tooltip: {
      enabled: false
    },
  
    // the value axis
    yAxis: {
      stops: [
        [0.1, "#DF5353"], // red
        [0.5, "#DDDF0D"], // yellow
        [0.9, "#55BF3B"] // green
      ],
      lineWidth: 0,
      minorTickInterval: null,
      tickAmount: 2,
      title: {
        y: -70
      },
      labels: {
        y: 16
      }
    },
  
    plotOptions: {
      solidgauge: {
        dataLabels: {
          y: 5,
          borderWidth: 0,
          useHTML: true
        }
      }
    }
  };/**
 * The minimum history length is current khatma number - 1, suras with that mimimum history length are in the completed set, other suras are not completed yet.
 */
function getKhatmaProgressData() {
    var indexesOfSurasWithMinimumHistoryLength = [];
  
    //current minimum history length reached
    var minimumHistoryLength = surasHistory[1].history.length;
  
    //comulated char count of minimum history length suras
    var comulatedScoreOfCurrentMinimumHistoryLengthSuras = 0;
  
    var khatmaProgress = {};
  
    for (var suraIndex = 1; suraIndex <= 114; suraIndex++) {
      //check if current sura history length is less than current reached minimum
      if (surasHistory[suraIndex].history.length < minimumHistoryLength) {
        //reset mimimum
        minimumHistoryLength = surasHistory[suraIndex].history.length;
        indexesOfSurasWithMinimumHistoryLength = [suraIndex];
        comulatedScoreOfCurrentMinimumHistoryLengthSuras =
          suraCharCount[suraIndex - 1];
      }
      //check if current sura history equals current reached mimimum
      else if (surasHistory[suraIndex].history.length == minimumHistoryLength) {
        indexesOfSurasWithMinimumHistoryLength.push(suraIndex);
        comulatedScoreOfCurrentMinimumHistoryLengthSuras +=
          suraCharCount[suraIndex - 1];
      } else {
      }
    }
  
    khatmaProgress.data = [
      {
        name: "Remaining",
        y: comulatedScoreOfCurrentMinimumHistoryLengthSuras,
        sliced: true,
        selected: true,
        drilldown: "Remaining"
      },
      {
        name: "Completed",
        y: fullKhatmaCharCount - comulatedScoreOfCurrentMinimumHistoryLengthSuras,
        drilldown: "Completed"
      }
    ];
  
    //extract current khatma number
    khatmaProgress.currentKhatma = minimumHistoryLength + 1;
  
    var remainingDrillDownArray = [];
    var completedDrilldownArray = [];
    for (var index = 1; index <= 114; index++) {
      var entry = {
        name: SuraNamesEn[index - 1],
        y: suraCharCount[index - 1] //,
        //color: colorHash[index]
      };
      if (indexesOfSurasWithMinimumHistoryLength.indexOf(index) != -1) {
        remainingDrillDownArray.push(entry);
      } else {
        completedDrilldownArray.push(entry);
      }
    }
  
    remainingDrillDownArray = sortByKey(remainingDrillDownArray, "y");
    completedDrilldownArray = sortByKey(completedDrilldownArray, "y");
  
    khatmaProgress.drilldown = [
      {
        name: "Remaining",
        id: "Remaining",
        data: remainingDrillDownArray
      },
      {
        name: "Completed",
        id: "Completed",
        data: completedDrilldownArray
      }
    ];
  
    return khatmaProgress;
  }

  async function drawKhatmaPieChart() {
    var khatmaProgress = getKhatmaProgressData();
    var data = khatmaProgress.data;
  
    // Build the chart
    Highcharts.chart("khatma-progress-chart", {
      chart: {
        plotBackgroundColor: null,
        plotBorderWidth: null,
        plotShadow: false,
        type: "pie"
      },
      title: {
        text: "Khatma #" + khatmaProgress.currentKhatma + " Progress"
      },
      tooltip: {
        pointFormat: "{series.name}: <b>{point.percentage:.1f}%</b>"
      },
      plotOptions: {
        pie: {
          allowPointSelect: true,
          cursor: "pointer",
          dataLabels: {
            enabled: true,
            format: "<b>{point.name}</b>: {point.percentage:.1f} %",
            style: {
              color:
                (Highcharts.theme && Highcharts.theme.contrastTextColor) ||
                "green"
            },
            connectorColor: "silver"
          }
        }
      },
      series: [
        {
          name: "Khatma Progress",
          data: data
        }
      ],
  
      drilldown: {
        series: khatmaProgress.drilldown
      }
    });
  }function get_flat_timestamp_score_array() {
  var allEntries = [];

  for (cellIndex = 1; cellIndex <= 114; cellIndex++) {
    var history = surasHistory[cellIndex].history;
    for (entry = 0; entry < history.length; entry++) {
      var timestamp = history[entry] * 1000;
      allEntries.push([timestamp, suraCharCount[cellIndex - 1]]);
    }
  }

  if (allEntries.length == 0) {
    return [];
  }

  var sortedEntries = sortByX(allEntries);

  return sortedEntries;
}

/**
 * 
 * @param {*} divID 
 * @param {*} mode 0 dor days, 1 for months, 2 for years
 */

async function drawTimeSeriesChart(divID, mode) {
  var data = {};

  switch (mode) {
    case DARK_DAYS_MODE:
      data = dark_days_data();
      break;

    case LIGHT_DAYS_MODE:
      data = light_days_data();
      break;

    default:
      data = time_series_score_date(mode);
  }


  var chartTitle;
  switch (mode) {
    case DAILY_SCORE_MODE://daily chart
      chartTitle = "Daily Revenue";
      break;

    case MONTHLY_SCORE_MODE://monthly chart 
      chartTitle = "Monthly Revenue";
      break;

    case YEARLY_SCORE_MODE://yearly chart
      chartTitle = "Yearly Revenue";
      break;

    case DARK_DAYS_MODE:
      chartTitle = "Dark Days";
      break;

    case LIGHT_DAYS_MODE:
      chartTitle = "Bright Days";
      break;
  }
  Highcharts.chart(divID, {
    chart: {
      zoomType: "x"
    },
    title: {
      text: chartTitle
    },
    subtitle: {
      text:
        document.ontouchstart === undefined
          ? "Click and drag in the plot area to zoom in"
          : "Pinch the chart to zoom in"
    },
    xAxis: {
      type: "datetime"
    },
    yAxis: {
      title: {
        text: chartTitle
      }
    },
    legend: {
      enabled: false
    },
    plotOptions: {
      area: {
        fillColor: {
          linearGradient: {
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 1
          },
          stops: [
            [0, Highcharts.getOptions().colors[0]],
            [
              1,
              Highcharts.Color(Highcharts.getOptions().colors[0])
                .setOpacity(0)
                .get("rgba")
            ]
          ]
        },
        marker: {
          radius: 2
        },
        lineWidth: 1,
        states: {
          hover: {
            lineWidth: 1
          }
        },
        threshold: null
      }
    },

    series: [
      {
        type: "area",
        name: "Revenue",
        data: data
      }
    ]
  });
}

/**
*
* @param {*} mode 0 daily, 1 monthly, 2 yearly
*/
function time_series_score_date(mode) {
  //TODO add zeros for missing days
  var allEntries = [];
  dark_days_map = {};

  for (cellIndex = 1; cellIndex <= 114; cellIndex++) {
    var history = surasHistory[cellIndex].history;
    for (entry = 0; entry < history.length; entry++) {
      var timestamp = history[entry] * 1000;
      allEntries.push([timestamp, suraCharCount[cellIndex - 1]]);
    }
  }

  if (allEntries.length == 0) {
    return [];
  }

  var sortedEntries = sortByX(allEntries);

  var scoreArray = [];
  var periodScore = 0;
  var prevDate = new Date(sortedEntries[0][0]).getDate();
  var prevMonth = new Date(sortedEntries[0][0]).getMonth() + 1;
  var prevYear = new Date(sortedEntries[0][0]).getFullYear();

  var periodStartTimestamp = sortedEntries[0][0];
  var periodEndTimestamp = sortedEntries[0][0];
  for (var index = 0; index < sortedEntries.length; index++) {
    var date = new Date(sortedEntries[index][0]);
    var currentDate = date.getDate();
    var currentMonth = date.getMonth() + 1;
    var currentYear = date.getFullYear();

    //ّFIXME first time item not correct
    if (
      (mode == DAILY_SCORE_MODE && Number(prevDate) != Number(currentDate)) ||
      (mode == MONTHLY_SCORE_MODE && Number(prevMonth) != Number(currentMonth)) ||
      (mode == YEARLY_SCORE_MODE && Number(prevYear) != Number(currentYear))
    ) {
      //accumulate a full scoring period
      periodEndTimestamp = sortedEntries[index - 1][0];
      var periodTimestamp = (periodEndTimestamp - periodStartTimestamp) / 2 + periodStartTimestamp;
      periodStartTimestamp = sortedEntries[index][0];

      scoreArray.push([periodTimestamp, periodScore]);

      if (mode !== DARK_DAYS_MODE) {
        periodScore = sortedEntries[index][1];
      }
    } else {
      periodScore += sortedEntries[index][1];
      if (index == (sortedEntries.length - 1)) {
        scoreArray.push([sortedEntries[index][0], periodScore]);
      }
    }

    prevDate = currentDate;
    prevMonth = currentMonth;
    prevYear = currentYear;
  }

  return scoreArray;
}

function exportJSON() {
  var filename = "quran_lights_history.json";

  var blob = new Blob([export_history_to_json()], { type: "text/csv;charset=utf-8;" });
  if (navigator.msSaveBlob) {
    // IE 10+
    navigator.msSaveBlob(blob, filename);
  } else {
    var link = document.createElement("a");
    if (link.download !== undefined) {
      // feature detection
      // Browsers that support HTML5 download attribute
      var url = URL.createObjectURL(blob);
      link.setAttribute("href", url);
      link.setAttribute("download", filename);
      link.style.visibility = "hidden";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }
}

//TODO export and import using json format
function export_history_to_json() {
  return JSON.stringify(surasHistory, null, 2);
}

//TODO implement import from json
function importJSON() {
  showToast("Import Started...");
  var files = document.getElementById('selectFiles').files;
  if (files.length <= 0) {
    hideToast();
    alert("Choose Quran Lights history file to import!");
    return false;
  }

  var file_reader = new FileReader();
  file_reader.onload = function (e) {
    var result = is_json_string(e.target.result);
    console.log("imported & parser result: \n", result);
    if (result[0]) {
      var history = result[1];
      merge_imported_suras_history(history);
      add_sura_cells();
      hideToast();
      alert("IMPORT SUCCESS!");
    } else {
      hideToast();
      console.log("INVALID JSON!!");
      alert("INVALID JSON!!")
    }
  }

  file_reader.readAsText(files.item(0));
}

function create_refresh_transaction_record(sura_index, timestamp){
  var transaction_record = {
    op: "refresh",
    sura: sura_index,
    time: timestamp
  };

 return transaction_record;
}

function create_memorization_transaction_record(sura_index, timestamp, memorization_state){
  var transaction_record = {
    op: "memorize",
    sura: sura_index,
    state: memorization_state,
    time: timestamp
  };

 return transaction_record;
}

function create_refresh_transaction_batch(sura_index, timestamps) {
  var transactions = [];
  for(var key in timestamps) {
    var timestamp = timestamps[key];
    transactions.push(create_refresh_transaction_record(sura_index, timestamp));
  }

  return transactions;
}

function merge_imported_suras_history(history){
  var new_transactions = [];
  for (var suraIndex in history) {
    // Merge/update local refresh histories
    if (
      //both local and imported histories got entries
      surasHistory[suraIndex] && 
      surasHistory[suraIndex].history && 
      surasHistory[suraIndex].history.length > 0 && 
      history[suraIndex].history &&
      history[suraIndex].history.length > 0
      ) {
      //merge both histories
      console.log("Merge imported history for ", suraIndex);
      var new_records = history[suraIndex].history.filter( x => !surasHistory[suraIndex].history.includes(x));
      new_records.sort(sortNumber);
      new_transactions = new_transactions.concat(create_refresh_transaction_batch(suraIndex, new_records));
      history[suraIndex].history = new_records;
      surasHistory[suraIndex].history = surasHistory[suraIndex].history.concat(new_records);
      surasHistory[suraIndex].history.sort(sortNumber);
    } else {
      if (!surasHistory[suraIndex] || !surasHistory[suraIndex].history || surasHistory[suraIndex].history.length == 0) {
        console.log("Replace with imported history for ", suraIndex);
        surasHistory[suraIndex] = history[suraIndex];
        if (history[suraIndex] && history[suraIndex].history &&  history[suraIndex].history.length) {
          new_transactions = new_transactions.concat(create_refresh_transaction_batch(suraIndex, history[suraIndex].history));
        }
      }
    }

    if (history[suraIndex] !== null && history[suraIndex].memorization !== null) {
      if (!surasHistory[suraIndex]) {
        surasHistory[suraIndex] = {};
      }
      surasHistory[suraIndex].memorization = history[suraIndex].memorization;
      //TODO fix this tragendy: no memorization data in surasHistory
      new_transactions.push(create_memorization_transaction_record(suraIndex, get_time_stamp(), history[suraIndex].memorization));
    }
  }

  for (var suraIndex in surasHistory.keys) {
    surasHistory[suraIndex].history.sort(sortNumber);
  }

  set_local_storage_object("surasHistory", surasHistory);
  enqueue_batch_for_upload(new_transactions);
}const money_sound = "kaching.mp3";
async function playSuraRefreshSound() {
  var audio = new Audio(money_sound);
  audio.play();
}
function signInWithGoogle() {
    signInWithOAuth("google");
  }
  
  function signInWithOAuth(signInProvider) {
    switch (signInProvider) {
      case "google":
        console.log("sign in with google");
        var provider = new firebase.auth.GoogleAuthProvider();
        break;
  
      case "facebook":
        console.log("sign in with facebook");
        provider = new firebase.auth.FacebookAuthProvider();
        break;
  
      case "twitter":
        console.log("sign in with Twitter");
        provider = new firebase.auth.GoogleAuthProvider();
        break;
    }
  
    firebase
      .auth()
      .signInWithPopup(provider)
      .then(function(result) {
        // This gives you a Google Access Token. You can use it to access the Google API.
        var token = result.credential.accessToken;
        // The signed-in user info.
        user = result.user;
        // ...
      })
      .catch(function(error) {
        // Handle Errors here.
        var errorCode = error.code;
        var errorMessage = error.message;
        // The email of the user's account used.
        var email = error.email;
        // The firebase.auth.AuthCredential type that was used.
        var credential = error.credential;
        // ...
      });
  }
  
  function signInWithFacebook() {
    signInWithOAuth("facebook");
  }
  
  function signInWithTwitter() {
    signInWithOAuth("twitter");
  }
  /**
   * Handles the sign up button press.
   */
  function handleSignUp() {
    var email = document.getElementById("email").value;
    var password = document.getElementById("password").value;
    if (email.length < 4) {
      alert("Please enter an email address.");
      return;
    }
    if (password.length < 4) {
      alert("Please enter a password.");
      return;
    }
    // Sign in with email and pass.
    // [START createwithemail]
    firebase
      .auth()
      .createUserWithEmailAndPassword(email, password)
      .catch(function(error) {
        // Handle Errors here.
        var errorCode = error.code;
        var errorMessage = error.message;
        // [START_EXCLUDE]
        if (errorCode == "auth/weak-password") {
          alert("The password is too weak.");
        } else {
          alert(errorMessage);
        }
        console.log(error);
        // [END_EXCLUDE]
      });
    // [END createwithemail]
  }
  /**
   * Sends an email verification to the user.
   */
  function sendEmailVerification() {
    // [START sendemailverification]
    firebase
      .auth()
      .currentUser.sendEmailVerification()
      .then(function() {
        // Email Verification sent!
        // [START_EXCLUDE]
        alert("Email Verification Sent!");
        // [END_EXCLUDE]
      });
    // [END sendemailverification]
  }
  function sendPasswordReset() {
    var email = document.getElementById("email").value;
    // [START sendpasswordemail]
    firebase
      .auth()
      .sendPasswordResetEmail(email)
      .then(function() {
        // Password Reset Email Sent!
        // [START_EXCLUDE]
        alert("Password Reset Email Sent!");
        // [END_EXCLUDE]
      })
      .catch(function(error) {
        // Handle Errors here.
        var errorCode = error.code;
        var errorMessage = error.message;
        // [START_EXCLUDE]
        if (errorCode == "auth/invalid-email") {
          alert(errorMessage);
        } else if (errorCode == "auth/user-not-found") {
          alert(errorMessage);
        }
        console.log(error);
        // [END_EXCLUDE]
      });
    // [END sendpasswordemail];
  }
  function updateDeselectButton(){
  if (selected_suras.length > 0) {
    document.getElementById("deselect_button").style.display = "block";
  } else {
    //document.getElementById("deselect_button").style.display = "none";
  }
}

function toggle_select(suraIndex) {
    var index = selected_suras.indexOf(suraIndex);
    if (index !== -1) {
      selected_suras.splice(index, 1);
      $(".sura-" + suraIndex).removeClass("selected");
      if (is_old_refresh(suraIndex)) {
          $(".sura-" + suraIndex).addClass("old-refresh");
      }
    } else {
      selected_suras.push(Number(suraIndex));
      $(".sura-" + suraIndex).removeClass("old-refresh");
      $(".sura-" + suraIndex).addClass("selected");
    }
    set_local_storage_object("selected_suras", selected_suras);
    update_selection_score();
  }

  //update selected_total element with total selected suras score
  function update_selection_score() {
    var selected_total = 0;
  
    for (var i = 0; i < selected_suras.length;  i++) {
      selected_total += suraCharCount[selected_suras[i] - 1];
    }
  
    document.getElementById("selected_total").textContent = " Selected Amount: [" + formatter.format(selected_total) + "]";
  }

  function deselectAll() {
    if (selected_suras.length == 0) return;
    for (var index = 0; index < selected_suras.length; index++) {
      $(".sura-" + selected_suras[index]).removeClass("selected");
      if (is_old_refresh(selected_suras[index])) {
          $(".sura-" + selected_suras[index]).addClass("old-refresh");
      }
    }

    selected_suras = [];
    set_local_storage_object("selected_suras", selected_suras);
    update_selection_score();
  }

  function is_old_refresh(sura_index) {
    var timeStampsArray = surasHistory[sura_index].history;
    var currentTimeStamp = Math.floor(Date.now() / 1000);

    var maxStamp = timeStampsArray.length > 0
      ? timeStampsArray[timeStampsArray.length - 1]
      : get_initial_local_object("min_timestamp", currentTimeStamp);

    var daysElapsed = ((currentTimeStamp - maxStamp) /
      (60 * 60 * 24.0)).toFixed(0);
    console.log("(daysElapsed >= refreshPeriodDays): " + (daysElapsed >= get_refresh_period_days()));
    return  (daysElapsed >= get_refresh_period_days());
  }function getScore() {
    var total = 0;
    var today = 0;
    var read_today = new Set();
    var read_score = 0;
    var review_score = 0;
    var reviewed_today = new Set();
    var todayStart = todayStartTimeStamp();
    for (i = 1; i <= 114; i++) {
      var suraScore = suraCharCount[i - 1];
      var history = surasHistory[i].history;
      if (history == null) {
        history = [];
      }
      total = total + Number(history.length) * Number(suraScore);
      var lastEntryIndex = history.length - 1;
      //timestamps are sorted so we will start from their top going backward until we exceed today's start
      //TODO add a today-refreshed sura index to read_today if not memorized, add it to reviewd if memorized
      while (lastEntryIndex >= 0 && history[lastEntryIndex] >= todayStart) {
        if (surasHistory[i].memorization == MEMORIZATION_STATE_MEMORIZED) {
          if (!reviewed_today.has(i)) {
            reviewed_today.add(i);
            review_score += suraScore;
          }
        }
        else {
          if (!read_today.has(i)) {
            read_today.add(i);
            read_score += suraScore;
          }
        }
        today += suraScore;
        lastEntryIndex--;
      }
    }

    scores = {"total": total, "today_total": today, "today_review": review_score, "today_read": read_score};

    return [total, today, review_score, read_score];
  }

  function update_score () {
    var score_array = getScore();
    review_today = score_array[2];
    console.log(score_array);
    document.getElementById("score").textContent = "Total Balance: " + format(score_array[0]);
    document.getElementById("today_score").textContent = "Today Revenue: " + format(score_array[1]);
    document.getElementById("today_review_score").textContent = "* Review Revenue: " + format(review_today) + " of [" + format(memorization_state["memorized"] / get_refresh_period_days()) +"]";
    document.getElementById("today_read_score").textContent = "* Read Revenue: " + format(score_array[3]) + " of [" + format(memorization_state["not_memorized"] / get_refresh_period_days()) +"]";;
    animate_score();
  }

  async function animate_score() {
    document.getElementById("today_score").className = "score";
    //TODO test it!
    //document.getElementById("today_score").className = "score animated bounceIn";
    $("#today_score").addClass("animated bounceIn");
  }var click_event_queue = [];

async function add_sura_cells() {
  console.log("add_sura_cells invoked.");
  //TODO reuse cells
  if (buildingSurasFlag) {
    return;
  }
  surasColorTable = [];
  buildingSurasFlag = true;
  clear_reviews();
  
  var currentTimeStamp = Math.floor(Date.now() / 1000);
  var refreshPeriod = get_refresh_period_days() * 24 * 60 * 60;
  lightRatio = 0;
  conquerRatio = 0;
  for (var cellIndex = 1; cellIndex <= 114; cellIndex++) {
    var suraIndex = sortedSuraIndexConverter(cellIndex);
    var element = document.createElement("button");
    element.index = suraIndex;
    element.className = "sura-cell" + " sura-" + suraIndex + " animated bounceIn";
    if (surasHistory[suraIndex] == null) {
      surasHistory[suraIndex] = {};
      surasHistory[suraIndex].history = [];
      surasHistory[suraIndex].suraIndex = suraIndex;
      surasHistory[suraIndex].memorization = MEMORIZATION_STATE_NOT_MEMORIZED;
    }
    var timeStampsArray = surasHistory[suraIndex].history;
    //TODO if not refreshed before make it zero instead of (currentTimeStamp - refreshPeriod) and condition timeDifferenceRatio value to be zero too
    //TODO use minimum timestamp in all suras otherwise save current time as that minimum for later calculations
    var maxStamp = timeStampsArray.length > 0
      ? timeStampsArray[timeStampsArray.length - 1]
      : get_initial_local_object("min_timestamp", currentTimeStamp);
    var timeDifferenceRatio = 1 -
      ((currentTimeStamp -
        (maxStamp == 0 ? currentTimeStamp - refreshPeriod : maxStamp)) *
        1.0) /
      refreshPeriod;
    timeDifferenceRatio = timeDifferenceRatio < 0 ? 0 : timeDifferenceRatio;
    lightRatio +=
      ((timeDifferenceRatio * suraCharCount[suraIndex - 1]) /
        fullKhatmaCharCount) *
      100.0;
    conquerRatio +=
      currentTimeStamp - maxStamp < refreshPeriod
        ? (suraCharCount[suraIndex - 1] / fullKhatmaCharCount) * 100.0
        : 0;
    var greenComponent = (255.0 * timeDifferenceRatio).toFixed(0);
    if (timeStampsArray.length > 0) {
      element.style.backgroundColor = "rgb(0," + greenComponent + ",0)";
      surasColorTable[suraIndex - 1] = (greenComponent / 255) * 114;
    }
    else {
      element.style.backgroundImage = "url('images/desert.jpg')";
      surasColorTable[suraIndex - 1] = 0;
    }
    colorHash[cellIndex] = rgbToHex(0, greenComponent, 0);
    var daysElapsed = ((currentTimeStamp - maxStamp) /
      (60 * 60 * 24.0)).toFixed(0);
      elapsed_days[suraIndex - 1] = Number(daysElapsed);
    if (selected_suras.indexOf(suraIndex) !== -1) {
      element.classList.add("selected");
    }
    else if (daysElapsed >= get_refresh_period_days()) {
      element.classList.add("old-refresh");
    }

    var header = document.createElement("div");
    header.className = "cell_header";

    var verseCount = suraVerseCount[suraIndex - 1];
    var sura_verse_count_element = document.createElement("div");
    sura_verse_count_element.className = "sura_verse_count";
    sura_verse_count_element.textContent = verseCount + "V";
    header.appendChild(sura_verse_count_element);

    var sura_index_element = document.createElement("div");
    sura_index_element.className = "sura_index";
    sura_index_element.textContent = "#" + suraIndex;
    header.appendChild(sura_index_element);

    element.appendChild(header);

    var suraName = SuraNamesEn[suraIndex - 1];
    var daysElapsedText = daysElapsed == 0 ? "" : get_humanized_period(daysElapsed);

    var suraNameElement = document.createElement("div");
    var suraNameElementAr = document.createElement("div");
    suraNameElement.className = "sura_name_label";
    suraNameElementAr.textContent = SuraNamesAr[suraIndex - 1];
    suraNameElementAr.className = "sura_name_label";
    switch (surasHistory[suraIndex].memorization) {
      case MEMORIZATION_STATE_MEMORIZED:
        if (daysElapsed >= MAX_ELAPSED_DAYS_FOR_MEMORIZED_SURAS || daysElapsed >= get_refresh_period_days()) {
          suraNameElement.className = "old-memorized sura_name_label";
        }
        else {
          suraNameElement.className = "memorized sura_name_label";
          suraNameElement.style.backgroundColor = "rgba(255, 255, 0," + (MAX_ELAPSED_DAYS_FOR_MEMORIZED_SURAS - daysElapsed) / MAX_ELAPSED_DAYS_FOR_MEMORIZED_SURAS + ")";
        }
        break;
      default:
        suraNameElement.className = "not_memorized sura_name_label";
    }
    if (timeDifferenceRatio >= 0.5) {
      element.style.color = "black";
    }
    else {
      element.style.color = "white";
    }
    suraNameElement.textContent = suraName;
    element.appendChild(suraNameElementAr);
    element.appendChild(suraNameElement);

    var charCountText = SCORE_CURRENCY + readableFormat(suraCharCount[suraIndex - 1]);
    //Char count
    var charCountElement = document.createElement("span");
    charCountElement.className = "char-count";
    charCountElement.textContent = charCountText;
    element.appendChild(charCountElement);
    //Days elapsed
    if (daysElapsed != 0) {
      var daysElapsedElement = document.createElement("span"); //document.createTextNode(daysElapsedText);
      daysElapsedElement.className = "elapsed_days";
      daysElapsedElement.textContent = daysElapsedText;
      // daysElapsedElement.id = "days";
      element.appendChild(daysElapsedElement);
    }

    Array.from(element.children).forEach((child)=> {
      $(child).addClass("noselect");
    })
  
    element.onclick = function() {
      click_handler(this.index);
    };

    element.onmouseenter = function(event) {
      if(event.buttons) {
        toggle_select(this.index);
      }
    }

    document.getElementById("reviews").appendChild(element);
  }
  buildingSurasFlag = false;
  $("#reviews").addClass("animated bounce");
  setup_light_days_options();
  updateDeselectButton();
  update_selection_score();
  update_charts();
  update_score();
  //periodically refresh
  if (periodicRefreshTimerRef != null) {
    clearInterval(periodicRefreshTimerRef);
  }
  periodicRefreshTimerRef = setInterval(add_sura_cells, AUTO_REFRESH_PERIOD);
}

function do_double_click(index){
  while(click_event_queue.length > 0 && click_event_queue[0].index == index) {
    console.log("dropped click entry for ", index);
    click_event_queue.shift()
  }
  
  var timeStamp = Math.floor(Date.now() / 1000);
  $(".sura-" + index).addClass("animated bounceIn");
  refreshSura(index, timeStamp);
}

function do_click() {
  if (click_event_queue.length == 0) return;

  var event = click_event_queue.pop();
  if (!event) {
    console.log("Empty click event queue.");
    return;
  }

  console.log("Delayed click event on cell: ", event.index);
  if (event.alt_pressed) {
    $(".sura-" + event.index).addClass("animated bounceIn");
    toggle_memorization(event.index);
  } else if(event.shift_pressed) {
    window.open("http://quran.ksu.edu.sa/index.php?l=en#aya=" + event.index + "_1&m=hafs&qaree=tunaiji&trans=en_sh");
  } else {
    toggle_select(event.index);
  }
}

//TODO fix this: this.index how to pass parameter
var click_handler = function (index) {
  if (click_event_queue.length > 0 && click_event_queue[0].index == index) {
    console.log("double click detected.");
    do_double_click(index);
  } else {
    var click_event = {};
    click_event.index = index;
    click_event.alt_pressed = alt_pressed;
    click_event.shift_pressed = shift_pressed;
    click_event.ctrl_pressed = ctrl_pressed;
    click_event.cmd_pressed = cmd_pressed;

    click_event_queue.unshift(click_event);
    setTimeout(do_click, SINGLE_CLICK_EVENT_DAMPING_DELAY);
  }
};/**
 * Handles the sign in button press.
 */
function toggleSignIn() {
  if (firebase.auth().currentUser) {
    clear_reviews();
    showToast("Signing out...");
    // [START signout]
    firebase.auth().signOut();
    document.getElementById("quickstart-sign-in").textContent = "Sign in";
    document.getElementById("sign-in-with-google").textContent =
      "Sign In with Google";
    //document.getElementById('sign-in-with-facebook').textContent = 'Sign In with Facebook';
    //document.getElementById('sign-in-with-twitter').textContent = 'Sign In with Twitter';
    //empty score
    document.getElementById("score").textContent = "--";
    document.getElementById("email").value = "";
    document.getElementById("password").value = "";
    document.getElementById("daily-score-chart").innerHTML = "";
    document.getElementById("radar-chart").innerHTML = "";
    document.getElementById("monthly-score-chart").innerHTML = "";
    document.getElementById("dark_days_chart").innerHTML = "";
    document.getElementById("light_days_chart").innerHTML = "";
    document.getElementById("yearly-score-chart").innerHTML = "";
    document.getElementById("khatma-progress-chart").innerHTML = "";
    document.getElementById("treemap-chart").innerHTML = "";
    document.getElementById("memorization-chart").innerHTML = "";
    document.getElementById("conquer-ratio-chart-container").innerHTML = "";
    document.getElementById("light-ratio-chart-container").innerHTML = "";
    document.getElementById("sort_order").style.display = "none";
    document.getElementById("selected_total").style.display = "none";
    
    surasHistory = {};
    hideToast();
    // [END signout]
  }
  else {
    showToast("Signing in...");
    var email = document.getElementById("email").value;
    var password = document.getElementById("password").value;
    if (email.length < 4) {
      alert("Please enter an email address.");
      return;
    }
    if (password.length < 4) {
      alert("Please enter a password.");
      return;
    }
    // Sign in with email and pass.
    // [START authwithemail]
    firebase
      .auth()
      .signInWithEmailAndPassword(email, password)
      .catch(function (error) {
        // Handle Errors here.
        var errorCode = error.code;
        var errorMessage = error.message;
        // [START_EXCLUDE]
        if (errorCode === "auth/wrong-password") {
          alert("Wrong password.");
        }
        else {
          alert(errorMessage);
        }
        console.log(error);
        document.getElementById("quickstart-sign-in").disabled = false;
        document.getElementById("quickstart-sign-in").textContent = "Sign in";
        // [END_EXCLUDE]
      });
    hideToast();
    // [END authwithemail]
  }
  document.getElementById("quickstart-sign-in").disabled = false;
}
//TODO use async for all UI update operations!!
async function update_charts() {
    drawMemorizationPieChart();
    //TODO update ticket https://trello.com/c/qf6EoLOB/106-1-daily-review-gauge-calculation
    updateGuageChart("review_score_guage", 
                     "Today Review Revenue [" + format(scores["today_review"]) + " of Target " + format(get_review_werd()) + "]", 
                     100 * review_today / get_review_werd());
    updateGuageChart("daily-read-guage", "Today Read Revenue [" + format(scores["today_read"]) + " of Target " + format(get_read_werd()) + "]",
                    100 * get_today_read() / get_read_werd());
    updateGuageChart("light-ratio-chart-container", "Light Ratio", lightRatio);
    updateGuageChart("conquer-ratio-chart-container", "Conquer Ratio", conquerRatio);
    drawTimeSeriesChart("daily-score-chart", DAILY_SCORE_MODE);
    drawTimeSeriesChart("monthly-score-chart", MONTHLY_SCORE_MODE);
    drawTimeSeriesChart("yearly-score-chart", YEARLY_SCORE_MODE);
    drawTimeSeriesChart("dark_days_chart", DARK_DAYS_MODE);
    drawTimeSeriesChart("light_days_chart", LIGHT_DAYS_MODE);
    drawKhatmaPieChart();
    drawTreeMapChart("treemap-chart");
    drawRadarChart("radar-chart");
}

function get_review_werd(){
    return memorization_state["memorized"] / get_refresh_period_days();
}

function get_read_werd() {
    return (get_non_memorized_amount() / get_refresh_period_days());
}

function get_today_read() {
    console.log("today_read: " + scores["today_read"]);
  return scores["today_read"];
}

function get_non_memorized_amount(){
  return memorization_state["not_memorized"];
}async function drawRadarChart(divID) {
    Highcharts.chart(divID, {

        chart: {
            polar: true,
            type: 'line'
        },

        accessibility: {
            description: 'A spiderweb chart compares the allocated budget against actual spending within an organization. The spider chart has six spokes. Each spoke represents one of the 6 departments within the organization: sales, marketing, development, customer support, information technology and administration. The chart is interactive, and each data point is displayed upon hovering. The chart clearly shows that 4 of the 6 departments have overspent their budget with Marketing responsible for the greatest overspend of $20,000. The allocated budget and actual spending data points for each department are as follows: Sales. Budget equals $43,000; spending equals $50,000. Marketing. Budget equals $19,000; spending equals $39,000. Development. Budget equals $60,000; spending equals $42,000. Customer support. Budget equals $35,000; spending equals $31,000. Information technology. Budget equals $17,000; spending equals $26,000. Administration. Budget equals $10,000; spending equals $14,000.'
        },

        title: {
            text: 'Quran Radar',
        },

        pane: {
            size: '80%'
        },

        xAxis: {
            //suras names here
            categories: SuraNamesEn,
            tickmarkPlacement: 'on',
            lineWidth: 0
        },

        yAxis: {
            gridLineInterpolation: 'polygon',
            lineWidth: 0,
            min: 0
        },

        tooltip: {
            shared: true,
            pointFormat: '<span style="color:{series.color}">{series.name}: <b>{point.y:,.0f}</b><br/>'
        },

        legend: {
            align: 'right',
            verticalAlign: 'middle'
        },

        series: [{
            name: 'Elapsed days',
            //TODO put suras elapsed days here
            data: elapsed_days,
            pointPlacement: 'on'
        }],

        responsive: {
            rules: [{
                condition: {
                    maxWidth: 5000
                },
                chartOptions: {
                    legend: {
                        align: 'center',
                        verticalAlign: 'bottom'
                    },
                    pane: {
                        size: '70%'
                    }
                }
            }]
        }

    });
}